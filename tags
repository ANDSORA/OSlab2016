!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BOOT	Makefile	/^BOOT   := boot.bin$/;"	m
BOOT_C	Makefile	/^BOOT_C := $(wildcard $(BOOT_DIR)\/*.c)$/;"	m
BOOT_DIR	Makefile	/^BOOT_DIR       := boot$/;"	m
BOOT_O	Makefile	/^BOOT_O := $(BOOT_S:%.S=$(OBJ_DIR)\/%.o)$/;"	m
BOOT_S	Makefile	/^BOOT_S := $(wildcard $(BOOT_DIR)\/*.S)$/;"	m
CC	Makefile	/^CC      := gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS := -Wall -Werror -Wfatal-errors #开启所有警告, 视警告为错误, 第一个错误结束编译$/;"	m
CR0_AM	lib/mmu.h	86;"	d
CR0_CD	lib/mmu.h	88;"	d
CR0_EM	lib/mmu.h	81;"	d
CR0_ET	lib/mmu.h	83;"	d
CR0_MP	lib/mmu.h	80;"	d
CR0_NE	lib/mmu.h	84;"	d
CR0_NW	lib/mmu.h	87;"	d
CR0_PE	lib/mmu.h	79;"	d
CR0_PG	lib/mmu.h	89;"	d
CR0_TS	lib/mmu.h	82;"	d
CR0_WP	lib/mmu.h	85;"	d
CR4_DE	lib/mmu.h	94;"	d
CR4_MCE	lib/mmu.h	92;"	d
CR4_PCE	lib/mmu.h	91;"	d
CR4_PSE	lib/mmu.h	93;"	d
CR4_PVI	lib/mmu.h	96;"	d
CR4_TSD	lib/mmu.h	95;"	d
CR4_VME	lib/mmu.h	97;"	d
DD	Makefile	/^DD      := dd$/;"	m
DEPS	Makefile	/^DEPS := $(shell find -name "*.d")$/;"	m
ELF_MAGIC	lib/elf.h	4;"	d
ELF_PROG_FLAG_EXEC	lib/elf.h	52;"	d
ELF_PROG_FLAG_READ	lib/elf.h	54;"	d
ELF_PROG_FLAG_WRITE	lib/elf.h	53;"	d
ELF_PROG_LOAD	lib/elf.h	49;"	d
ELF_SHN_UNDEF	lib/elf.h	63;"	d
ELF_SHT_NULL	lib/elf.h	57;"	d
ELF_SHT_PROGBITS	lib/elf.h	58;"	d
ELF_SHT_STRTAB	lib/elf.h	60;"	d
ELF_SHT_SYMTAB	lib/elf.h	59;"	d
Elf	lib/elf.h	/^struct Elf {$/;"	s
Elf::e_ehsize	lib/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf	access:public
Elf::e_elf	lib/elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf	access:public
Elf::e_entry	lib/elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf	access:public
Elf::e_flags	lib/elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf	access:public
Elf::e_machine	lib/elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf	access:public
Elf::e_magic	lib/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf	access:public
Elf::e_phentsize	lib/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf	access:public
Elf::e_phnum	lib/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf	access:public
Elf::e_phoff	lib/elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf	access:public
Elf::e_shentsize	lib/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf	access:public
Elf::e_shnum	lib/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf	access:public
Elf::e_shoff	lib/elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf	access:public
Elf::e_shstrndx	lib/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf	access:public
Elf::e_type	lib/elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf	access:public
Elf::e_version	lib/elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf	access:public
FEC_PR	lib/mmu.h	123;"	d
FEC_U	lib/mmu.h	125;"	d
FEC_WR	lib/mmu.h	124;"	d
FL_AC	lib/mmu.h	117;"	d
FL_AF	lib/mmu.h	102;"	d
FL_CF	lib/mmu.h	100;"	d
FL_DF	lib/mmu.h	107;"	d
FL_ID	lib/mmu.h	120;"	d
FL_IF	lib/mmu.h	106;"	d
FL_IOPL_0	lib/mmu.h	110;"	d
FL_IOPL_1	lib/mmu.h	111;"	d
FL_IOPL_2	lib/mmu.h	112;"	d
FL_IOPL_3	lib/mmu.h	113;"	d
FL_IOPL_MASK	lib/mmu.h	109;"	d
FL_NT	lib/mmu.h	114;"	d
FL_OF	lib/mmu.h	108;"	d
FL_PF	lib/mmu.h	101;"	d
FL_RF	lib/mmu.h	115;"	d
FL_SF	lib/mmu.h	104;"	d
FL_TF	lib/mmu.h	105;"	d
FL_VIF	lib/mmu.h	118;"	d
FL_VIP	lib/mmu.h	119;"	d
FL_VM	lib/mmu.h	116;"	d
FL_ZF	lib/mmu.h	103;"	d
GDB	Makefile	/^GDB     := gdb$/;"	m
GDB_OPTIONS	Makefile	/^GDB_OPTIONS := -ex "target remote 127.0.0.1:1234"$/;"	m
GDT_ENTRY	boot/boot.S	/^#define GDT_ENTRY(n)	\\$/;"	d
Gatedesc	lib/mmu.h	/^struct Gatedesc {$/;"	s
Gatedesc::gd_args	lib/mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_dpl	lib/mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_off_15_0	lib/mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_off_31_16	lib/mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_p	lib/mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_rsv1	lib/mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_s	lib/mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_sel	lib/mmu.h	/^	unsigned gd_sel : 16;        \/\/ segment selector$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_type	lib/mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc	access:public
IMAGE	Makefile	/^IMAGE  := disk.bin$/;"	m
JOS_INC_ELF_H	lib/elf.h	2;"	d
JOS_INC_MMU_H	lib/mmu.h	2;"	d
JOS_INC_TYPES_H	lib/types.h	2;"	d
JOS_INC_X86_H	lib/x86.h	2;"	d
KERNEL	Makefile	/^KERNEL := kernel.bin$/;"	m
KERNEL_C	Makefile	/^KERNEL_C := $(shell find $(KERNEL_DIR) -name "*.c")$/;"	m
KERNEL_DIR	Makefile	/^KERNEL_DIR     := kernel$/;"	m
KERNEL_O	Makefile	/^KERNEL_O := $(KERNEL_C:%.c=$(OBJ_DIR)\/%.o)$/;"	m
KERNEL_S	Makefile	/^KERNEL_S := $(wildcard $(KERNEL_DIR)\/*.S)$/;"	m
LD	Makefile	/^LD      := ld$/;"	m
LD_SCRIPT	Makefile	/^LD_SCRIPT := $(shell find $(KERNEL_DIR) -name "*.ld")$/;"	m
LIB_C	Makefile	/^LIB_C := $(wildcard $(LIB_DIR)\/*.c)$/;"	m
LIB_DIR	Makefile	/^LIB_DIR        := lib$/;"	m
LIB_O	Makefile	/^LIB_O := $(LIB_C:%.c=$(OBJ_DIR)\/%.o)$/;"	m
MAX	lib/types.h	49;"	d
MIN	lib/types.h	43;"	d
MOMOKO_HEIGHT	lib/logo.h	/^const unsigned int MOMOKO_HEIGHT = 200;$/;"	v
MOMOKO_WIDTH	lib/logo.h	/^const unsigned int MOMOKO_WIDTH = 320;$/;"	v
MOMOKO_pixel	lib/logo.h	/^const unsigned char MOMOKO_pixel[] = {$/;"	v
NPDENTRIES	lib/mmu.h	45;"	d
NPTENTRIES	lib/mmu.h	46;"	d
NR_PALETTE_ENTRY	kernel/device/palette.c	10;"	d	file:
NULL	lib/types.h	5;"	d
OBJCOPY	Makefile	/^OBJCOPY := objcopy$/;"	m
OBJ_BOOT_DIR	Makefile	/^OBJ_BOOT_DIR   := $(OBJ_DIR)\/$(BOOT_DIR)$/;"	m
OBJ_DIR	Makefile	/^OBJ_DIR        := obj$/;"	m
OBJ_KERNEL_DIR	Makefile	/^OBJ_KERNEL_DIR := $(OBJ_DIR)\/$(KERNEL_DIR)$/;"	m
OBJ_LIB_DIR	Makefile	/^OBJ_LIB_DIR    := $(OBJ_DIR)\/$(LIB_DIR)$/;"	m
PDX	lib/mmu.h	33;"	d
PDXSHIFT	lib/mmu.h	55;"	d
PGADDR	lib/mmu.h	42;"	d
PGNUM	lib/mmu.h	30;"	d
PGOFF	lib/mmu.h	39;"	d
PGSHIFT	lib/mmu.h	49;"	d
PGSIZE	lib/mmu.h	48;"	d
PORT	kernel/serial.c	3;"	d	file:
PTE_A	lib/mmu.h	63;"	d
PTE_ADDR	lib/mmu.h	76;"	d
PTE_AVAIL	lib/mmu.h	70;"	d
PTE_D	lib/mmu.h	64;"	d
PTE_G	lib/mmu.h	66;"	d
PTE_P	lib/mmu.h	58;"	d
PTE_PCD	lib/mmu.h	62;"	d
PTE_PS	lib/mmu.h	65;"	d
PTE_PWT	lib/mmu.h	61;"	d
PTE_SYSCALL	lib/mmu.h	73;"	d
PTE_U	lib/mmu.h	60;"	d
PTE_W	lib/mmu.h	59;"	d
PTSHIFT	lib/mmu.h	52;"	d
PTSIZE	lib/mmu.h	51;"	d
PTX	lib/mmu.h	36;"	d
PTXSHIFT	lib/mmu.h	54;"	d
Proghdr	lib/elf.h	/^struct Proghdr {$/;"	s
Proghdr::p_align	lib/elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr	access:public
Proghdr::p_filesz	lib/elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr	access:public
Proghdr::p_flags	lib/elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr	access:public
Proghdr::p_memsz	lib/elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr	access:public
Proghdr::p_offset	lib/elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr	access:public
Proghdr::p_pa	lib/elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr	access:public
Proghdr::p_type	lib/elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr	access:public
Proghdr::p_va	lib/elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr	access:public
Pseudodesc	lib/mmu.h	/^struct Pseudodesc {$/;"	s
Pseudodesc::pd_base	lib/mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc	access:public
Pseudodesc::pd_lim	lib/mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc	access:public
QEMU	Makefile	/^QEMU    := qemu-system-i386$/;"	m
QEMU_DEBUG_OPTIONS	Makefile	/^QEMU_DEBUG_OPTIONS := -S #启动不执行$/;"	m
QEMU_OPTIONS	Makefile	/^QEMU_OPTIONS := -serial stdio #以标准输入输为串口(COM1)$/;"	m
ROUNDDOWN	lib/types.h	58;"	d
ROUNDUP	lib/types.h	64;"	d
SCR_HEIGHT	lib/device/video.h	7;"	d
SCR_SIZE	lib/device/video.h	8;"	d
SCR_WIDTH	lib/device/video.h	6;"	d
SECTSIZE	boot/main.c	5;"	d	file:
SEG	lib/mmu.h	142;"	d
SEG	lib/mmu.h	172;"	d
SEG16	lib/mmu.h	176;"	d
SEG_FAULT	lib/mmu.h	170;"	d
SEG_NULL	lib/mmu.h	139;"	d
SEG_NULL	lib/mmu.h	168;"	d
SETCALLGATE	lib/mmu.h	296;"	d
SETGATE	lib/mmu.h	282;"	d
STA_A	lib/mmu.h	189;"	d
STA_C	lib/mmu.h	186;"	d
STA_E	lib/mmu.h	185;"	d
STA_R	lib/mmu.h	188;"	d
STA_W	lib/mmu.h	187;"	d
STA_X	lib/mmu.h	184;"	d
STS_CG16	lib/mmu.h	195;"	d
STS_CG32	lib/mmu.h	201;"	d
STS_IG16	lib/mmu.h	197;"	d
STS_IG32	lib/mmu.h	202;"	d
STS_LDT	lib/mmu.h	193;"	d
STS_T16A	lib/mmu.h	192;"	d
STS_T16B	lib/mmu.h	194;"	d
STS_T32A	lib/mmu.h	199;"	d
STS_T32B	lib/mmu.h	200;"	d
STS_TG	lib/mmu.h	196;"	d
STS_TG16	lib/mmu.h	198;"	d
STS_TG32	lib/mmu.h	203;"	d
Secthdr	lib/elf.h	/^struct Secthdr {$/;"	s
Secthdr::sh_addr	lib/elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_addralign	lib/elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_entsize	lib/elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_flags	lib/elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_info	lib/elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_link	lib/elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_name	lib/elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_offset	lib/elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_size	lib/elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_type	lib/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr	access:public
Segdesc	lib/mmu.h	/^struct Segdesc {$/;"	s
Segdesc::sd_avl	lib/mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_15_0	lib/mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_23_16	lib/mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_31_24	lib/mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_db	lib/mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc	access:public
Segdesc::sd_dpl	lib/mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc	access:public
Segdesc::sd_g	lib/mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc	access:public
Segdesc::sd_lim_15_0	lib/mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc	access:public
Segdesc::sd_lim_19_16	lib/mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc	access:public
Segdesc::sd_p	lib/mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc	access:public
Segdesc::sd_rsv1	lib/mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc	access:public
Segdesc::sd_s	lib/mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc	access:public
Segdesc::sd_type	lib/mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc	access:public
Taskstate	lib/mmu.h	/^struct Taskstate {$/;"	s
Taskstate::ts_cr3	lib/mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate	access:public
Taskstate::ts_cs	lib/mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ds	lib/mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eax	lib/mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ebp	lib/mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ebx	lib/mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ecx	lib/mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_edi	lib/mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_edx	lib/mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eflags	lib/mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eip	lib/mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate	access:public
Taskstate::ts_es	lib/mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esi	lib/mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp	lib/mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp0	lib/mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp1	lib/mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp2	lib/mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_fs	lib/mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_gs	lib/mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_iomb	lib/mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ldt	lib/mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_link	lib/mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding1	lib/mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding10	lib/mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding2	lib/mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding3	lib/mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding4	lib/mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding5	lib/mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding6	lib/mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding7	lib/mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding8	lib/mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding9	lib/mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss	lib/mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss0	lib/mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss1	lib/mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss2	lib/mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_t	lib/mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate	access:public
VGA_DAC_DATA	kernel/device/palette.c	7;"	d	file:
VGA_DAC_READ_INDEX	kernel/device/palette.c	5;"	d	file:
VGA_DAC_WRITE_INDEX	kernel/device/palette.c	6;"	d	file:
VMEM_ADDR	lib/device/video.h	9;"	d
__PALETTE_H__	lib/device/palette.h	2;"	d
__VIDEO_H__	lib/device/video.h	2;"	d
bool	lib/types.h	/^typedef _Bool bool;$/;"	t
bootmain	boot/main.c	/^int bootmain(void)$/;"	f	signature:(void)
breakpoint	lib/x86.h	/^breakpoint(void)$/;"	f	signature:(void)
breakpoint	lib/x86.h	/^static __inline void breakpoint(void) __attribute__((always_inline));$/;"	p	signature:(void)
cpuid	lib/x86.h	/^cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)$/;"	f	signature:(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
cpuid	lib/x86.h	/^static __inline void cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp);$/;"	p	signature:(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
draw_pixel	lib/device/video.h	/^draw_pixel(int x, int y, int color) {$/;"	f	signature:(int x, int y, int color)
e_ehsize	lib/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf	access:public
e_elf	lib/elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf	access:public
e_entry	lib/elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf	access:public
e_flags	lib/elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf	access:public
e_machine	lib/elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf	access:public
e_magic	lib/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf	access:public
e_phentsize	lib/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf	access:public
e_phnum	lib/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf	access:public
e_phoff	lib/elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf	access:public
e_shentsize	lib/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf	access:public
e_shnum	lib/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf	access:public
e_shoff	lib/elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf	access:public
e_shstrndx	lib/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf	access:public
e_type	lib/elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf	access:public
e_version	lib/elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf	access:public
false	lib/types.h	/^enum { false, true };$/;"	e	enum:__anon1
gd_args	lib/mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc	access:public
gd_dpl	lib/mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc	access:public
gd_off_15_0	lib/mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc	access:public
gd_off_31_16	lib/mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc	access:public
gd_p	lib/mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc	access:public
gd_rsv1	lib/mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc	access:public
gd_s	lib/mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc	access:public
gd_sel	lib/mmu.h	/^	unsigned gd_sel : 16;        \/\/ segment selector$/;"	m	struct:Gatedesc	access:public
gd_type	lib/mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc	access:public
gdt	boot/boot.S	/^gdt:$/;"	l
gdtdesc	boot/boot.S	/^gdtdesc:$/;"	l
inb	lib/x86.h	/^inb(int port)$/;"	f	signature:(int port)
inb	lib/x86.h	/^static __inline uint8_t inb(int port) __attribute__((always_inline));$/;"	p	signature:(int port)
init_serial	kernel/game.c	/^void init_serial();$/;"	p	file:
init_serial	kernel/serial.c	/^void init_serial() {$/;"	f
init_vmem	kernel/device/video.c	/^init_vmem() {$/;"	f
init_vmem	kernel/game.c	/^void init_vmem();$/;"	p	file:
inl	lib/x86.h	/^inl(int port)$/;"	f	signature:(int port)
inl	lib/x86.h	/^static __inline uint32_t inl(int port) __attribute__((always_inline));$/;"	p	signature:(int port)
insb	lib/x86.h	/^insb(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insb	lib/x86.h	/^static __inline void insb(int port, void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, void *addr, int cnt)
insl	lib/x86.h	/^insl(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insl	lib/x86.h	/^static __inline void insl(int port, void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, void *addr, int cnt)
insw	lib/x86.h	/^insw(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insw	lib/x86.h	/^static __inline void insw(int port, void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, void *addr, int cnt)
int16_t	lib/types.h	/^typedef short int16_t;$/;"	t
int32_t	lib/types.h	/^typedef int int32_t;$/;"	t
int64_t	lib/types.h	/^typedef long long int64_t;$/;"	t
int8_t	lib/types.h	/^typedef __signed char int8_t;$/;"	t
intptr_t	lib/types.h	/^typedef int32_t intptr_t;$/;"	t
invlpg	lib/x86.h	/^invlpg(void *addr)$/;"	f	signature:(void *addr)
invlpg	lib/x86.h	/^static __inline void invlpg(void *addr) __attribute__((always_inline));$/;"	p	signature:(void *addr)
inw	lib/x86.h	/^inw(int port)$/;"	f	signature:(int port)
inw	lib/x86.h	/^static __inline uint16_t inw(int port) __attribute__((always_inline));$/;"	p	signature:(int port)
is_serial_idle	kernel/game.c	/^int is_serial_idle();$/;"	p	file:
is_serial_idle	kernel/serial.c	/^int is_serial_idle() {$/;"	f
lcr0	lib/x86.h	/^lcr0(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr0	lib/x86.h	/^static __inline void lcr0(uint32_t val) __attribute__((always_inline));$/;"	p	signature:(uint32_t val)
lcr3	lib/x86.h	/^lcr3(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr3	lib/x86.h	/^static __inline void lcr3(uint32_t val) __attribute__((always_inline));$/;"	p	signature:(uint32_t val)
lcr4	lib/x86.h	/^lcr4(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr4	lib/x86.h	/^static __inline void lcr4(uint32_t val) __attribute__((always_inline));$/;"	p	signature:(uint32_t val)
lgdt	lib/x86.h	/^lgdt(void *p)$/;"	f	signature:(void *p)
lidt	lib/x86.h	/^lidt(void *p)$/;"	f	signature:(void *p)
lidt	lib/x86.h	/^static __inline void lidt(void *p) __attribute__((always_inline));$/;"	p	signature:(void *p)
lldt	lib/x86.h	/^lldt(uint16_t sel)$/;"	f	signature:(uint16_t sel)
lldt	lib/x86.h	/^static __inline void lldt(uint16_t sel) __attribute__((always_inline));$/;"	p	signature:(uint16_t sel)
ltr	lib/x86.h	/^ltr(uint16_t sel)$/;"	f	signature:(uint16_t sel)
ltr	lib/x86.h	/^static __inline void ltr(uint16_t sel) __attribute__((always_inline));$/;"	p	signature:(uint16_t sel)
main	kernel/game.c	/^int main(void) {$/;"	f	signature:(void)
myread	tools/Image2Lcd.sh	/^myread() {$/;"	f
off_t	lib/types.h	/^typedef int32_t off_t;$/;"	t
offsetof	lib/types.h	71;"	d
outb	lib/x86.h	/^outb(int port, uint8_t data)$/;"	f	signature:(int port, uint8_t data)
outb	lib/x86.h	/^static __inline void outb(int port, uint8_t data) __attribute__((always_inline));$/;"	p	signature:(int port, uint8_t data)
outl	lib/x86.h	/^outl(int port, uint32_t data)$/;"	f	signature:(int port, uint32_t data)
outl	lib/x86.h	/^static __inline void outl(int port, uint32_t data) __attribute__((always_inline));$/;"	p	signature:(int port, uint32_t data)
outsb	lib/x86.h	/^outsb(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsb	lib/x86.h	/^static __inline void outsb(int port, const void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, const void *addr, int cnt)
outsl	lib/x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsl	lib/x86.h	/^static __inline void outsl(int port, const void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, const void *addr, int cnt)
outsw	lib/x86.h	/^outsw(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsw	lib/x86.h	/^static __inline void outsw(int port, const void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, const void *addr, int cnt)
outw	lib/x86.h	/^outw(int port, uint16_t data)$/;"	f	signature:(int port, uint16_t data)
outw	lib/x86.h	/^static __inline void outw(int port, uint16_t data) __attribute__((always_inline));$/;"	p	signature:(int port, uint16_t data)
p_align	lib/elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr	access:public
p_filesz	lib/elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr	access:public
p_flags	lib/elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr	access:public
p_memsz	lib/elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr	access:public
p_offset	lib/elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr	access:public
p_pa	lib/elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr	access:public
p_type	lib/elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr	access:public
p_va	lib/elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr	access:public
palette	kernel/device/palette.c	/^static uint8_t palette[NR_PALETTE_ENTRY * 4] = {$/;"	v	file:
pd_base	lib/mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc	access:public
pd_lim	lib/mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc	access:public
physaddr_t	lib/types.h	/^typedef uint32_t physaddr_t;$/;"	t
ppn_t	lib/types.h	/^typedef uint32_t ppn_t;$/;"	t
rcr0	lib/x86.h	/^rcr0(void)$/;"	f	signature:(void)
rcr0	lib/x86.h	/^static __inline uint32_t rcr0(void) __attribute__((always_inline));$/;"	p	signature:(void)
rcr2	lib/x86.h	/^rcr2(void)$/;"	f	signature:(void)
rcr2	lib/x86.h	/^static __inline uint32_t rcr2(void) __attribute__((always_inline));$/;"	p	signature:(void)
rcr3	lib/x86.h	/^rcr3(void)$/;"	f	signature:(void)
rcr3	lib/x86.h	/^static __inline uint32_t rcr3(void) __attribute__((always_inline));$/;"	p	signature:(void)
rcr4	lib/x86.h	/^rcr4(void)$/;"	f	signature:(void)
rcr4	lib/x86.h	/^static __inline uint32_t rcr4(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_ebp	lib/x86.h	/^read_ebp(void)$/;"	f	signature:(void)
read_ebp	lib/x86.h	/^static __inline uint32_t read_ebp(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_eflags	lib/x86.h	/^read_eflags(void)$/;"	f	signature:(void)
read_eflags	lib/x86.h	/^static __inline uint32_t read_eflags(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_esp	lib/x86.h	/^read_esp(void)$/;"	f	signature:(void)
read_esp	lib/x86.h	/^static __inline uint32_t read_esp(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_palette	lib/device/palette.h	/^void read_palette();$/;"	p	signature:()
read_tsc	lib/x86.h	/^read_tsc(void)$/;"	f	signature:(void)
read_tsc	lib/x86.h	/^static __inline uint64_t read_tsc(void) __attribute__((always_inline));$/;"	p	signature:(void)
readsect	boot/main.c	/^void readsect(void *dst, int offset) {$/;"	f	signature:(void *dst, int offset)
readseg	boot/main.c	/^void readseg(unsigned char *pa, int count, int offset) {$/;"	f	signature:(unsigned char *pa, int count, int offset)
readseg	boot/main.c	/^void readseg(unsigned char*,int,int);$/;"	p	file:	signature:(unsigned char*,int,int)
sd_avl	lib/mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc	access:public
sd_base_15_0	lib/mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_base_23_16	lib/mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_base_31_24	lib/mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_db	lib/mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc	access:public
sd_dpl	lib/mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc	access:public
sd_g	lib/mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc	access:public
sd_lim_15_0	lib/mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc	access:public
sd_lim_19_16	lib/mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc	access:public
sd_p	lib/mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc	access:public
sd_rsv1	lib/mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc	access:public
sd_s	lib/mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc	access:public
sd_type	lib/mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc	access:public
serial_output_test	kernel/game.c	/^void serial_output_test();$/;"	p	file:
serial_output_test	kernel/serial.c	/^void serial_output_test(){$/;"	f
serial_printc	kernel/game.c	/^void serial_printc(char);$/;"	p	file:	signature:(char)
serial_printc	kernel/serial.c	/^void serial_printc(char a){$/;"	f	signature:(char a)
sh_addr	lib/elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr	access:public
sh_addralign	lib/elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr	access:public
sh_entsize	lib/elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr	access:public
sh_flags	lib/elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr	access:public
sh_info	lib/elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr	access:public
sh_link	lib/elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr	access:public
sh_name	lib/elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr	access:public
sh_offset	lib/elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr	access:public
sh_size	lib/elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr	access:public
sh_type	lib/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr	access:public
size_t	lib/types.h	/^typedef uint32_t size_t;$/;"	t
ssize_t	lib/types.h	/^typedef int32_t ssize_t;$/;"	t
start	boot/boot.S	/^start:$/;"	l
start32	boot/boot.S	/^start32:$/;"	l
tlbflush	lib/x86.h	/^static __inline void tlbflush(void) __attribute__((always_inline));$/;"	p	signature:(void)
tlbflush	lib/x86.h	/^tlbflush(void)$/;"	f	signature:(void)
true	lib/types.h	/^enum { false, true };$/;"	e	enum:__anon1
ts_cr3	lib/mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate	access:public
ts_cs	lib/mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate	access:public
ts_ds	lib/mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate	access:public
ts_eax	lib/mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate	access:public
ts_ebp	lib/mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate	access:public
ts_ebx	lib/mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate	access:public
ts_ecx	lib/mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate	access:public
ts_edi	lib/mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate	access:public
ts_edx	lib/mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate	access:public
ts_eflags	lib/mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate	access:public
ts_eip	lib/mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate	access:public
ts_es	lib/mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate	access:public
ts_esi	lib/mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate	access:public
ts_esp	lib/mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate	access:public
ts_esp0	lib/mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate	access:public
ts_esp1	lib/mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate	access:public
ts_esp2	lib/mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate	access:public
ts_fs	lib/mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate	access:public
ts_gs	lib/mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate	access:public
ts_iomb	lib/mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate	access:public
ts_ldt	lib/mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate	access:public
ts_link	lib/mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate	access:public
ts_padding1	lib/mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate	access:public
ts_padding10	lib/mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate	access:public
ts_padding2	lib/mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate	access:public
ts_padding3	lib/mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate	access:public
ts_padding4	lib/mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate	access:public
ts_padding5	lib/mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate	access:public
ts_padding6	lib/mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate	access:public
ts_padding7	lib/mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate	access:public
ts_padding8	lib/mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate	access:public
ts_padding9	lib/mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate	access:public
ts_ss	lib/mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate	access:public
ts_ss0	lib/mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate	access:public
ts_ss1	lib/mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate	access:public
ts_ss2	lib/mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate	access:public
ts_t	lib/mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate	access:public
uint16_t	lib/types.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	lib/types.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	lib/types.h	/^typedef unsigned long long uint64_t;$/;"	t
uint8_t	lib/types.h	/^typedef unsigned char uint8_t;$/;"	t
uintptr_t	lib/types.h	/^typedef uint32_t uintptr_t;$/;"	t
vmem	kernel/device/video.c	/^uint8_t *vmem = ((uint8_t*)VMEM_ADDR);$/;"	v
waitdisk	boot/main.c	/^void waitdisk(void) {$/;"	f	signature:(void)
write_eflags	lib/x86.h	/^static __inline void write_eflags(uint32_t eflags) __attribute__((always_inline));$/;"	p	signature:(uint32_t eflags)
write_eflags	lib/x86.h	/^write_eflags(uint32_t eflags)$/;"	f	signature:(uint32_t eflags)
write_palette	kernel/device/palette.c	/^void write_palette() {$/;"	f
write_palette	kernel/game.c	/^void write_palette();$/;"	p	file:
write_palette	lib/device/palette.h	/^void write_palette();$/;"	p	signature:()
xchg	lib/x86.h	/^xchg(volatile uint32_t *addr, uint32_t newval)$/;"	f	signature:(volatile uint32_t *addr, uint32_t newval)
